# Команды git

- 'git help' и 'git help <command>'          - для вызова встроенной справки по гиту и его конкретным командам
- 'git init'                                 - инициализация репозитория в текущей рабочей папке
- 'git status'                               - просмотреть текущее состояние (статус) репозитория
- 'git add <filename/dirname>'               - добавить (подготовить) файл/папку для включения в коммит в репозиторий
- 'git add --all' / 'git add *'               - подготовить все файлы для включения в коммит
- 'git reset <filename/dirname>'             - исключить файл или папку из коммита
- 'git commit -m "описание коммита"'         - зафиксировать подготовленные файлы в репозитории (закоммитить)
- 'git diff <filename>'                      - посмотреть разницу между текущей версией файла и версией, зафиксированной в последнем коммите. Подробнее (например, сравнение двух коммитов) см. в документациии ('get help diff')
- 'git log'                                  - история коммитов с пояснением по каждому из них
- 'git log --pretty=format="%h %s --graph"   - наглядно отформатированная история с визуализацией дерева (веток) репозитория
- 'git blame <filename>'                     - выдаёт все строки файла с указанием коммитов и их авторов
- 'git branch <branch_name> <source_branch>' - создать новую ветку <branch_name> на основе <source_branch>
- 'git switch <branch_name>'                 - переключиться на указанную ветку с именем <branch_name>, она должна существовать
- 'git checkout -b <branch_name>'            - создать и сразу переключиться на новую ветку с именем <branch_name>

- 'git merge <branch_name>'                  - сделать слияние двух веток. По умолчанию указывается имя той ветки, **которую мы будем присоединять к текущей**
> Например, git merge dev при нахождении на ветке master присоединит ветку dev к ветке master

- 'git remote ...'                           - обеспечить локальное взаимодействие с удалённым репозиторием (добавление для работы в локальной среде, удаление ссылки на него из локальной среды, просмотр состояния удалённого репозитория). Подробнее см. в документации. 
- 'git remote add <name> <address>'          - простой вариант команды, пригодный для повседневных задач
> [!note]
> Пмя удалённого репозитория используется для удобной ссылки на него в вашей локальной среде; оно может быть любым, но должно быть уникальным в рамках ваших локальных сред
> По договорённости имя основного удалённого репозитория устанавливается как 'origin' 
> Если в команде 'git remote add' не указана ветка, то используется основная ветка удалённого репозитория (обычно 'master' или 'main')
- 'git remote add [-t <branch_name>] [-m <master_branch>] [-f] [--tags/--no-tags] [--mirror=<fetch|push>] <name> <address>'

- 'git push <name/url> [<branch>]'           - выгрузить текущее состояние локального репозитория (последний коммит) в указанный удалённый
> Потребуется авторизация на соответствующем сервисе и/или использовать учётные данные с этого сервиса при работе с локальным репозиторием
- 'git fetch <remote_repo>'                  - получить все коммиты из удалённого репозитория, но *никак не влиять на состояние локального репозитория*
- 'git pull <remote_repo>'                   - комбинация 'git fetch' и 'git merge', получить коммиты из удалённого репозитория и одновременно слить с текущей локальной веткой

- 'git clone <url>'                          - создать копию удалённого репозитория из указанного адреса на локальной машине и автоматически переключить созданную копию на основную ветку ('master'/'main')

- 'git revert <commit_id>'                   - откатить изменения (undo, Ctrl+Z и т.п.), внесённые предыдущим коммитом без изменения истории коммитов (создаётся новый коммит, содержащий обращение изменений отменяемого коммита)
- 'git reset'                                - более мощная версия отката изменений, **но и более опасная**, для повседневных нужд **не рекомендуется** (но см. документацию, если прижмёт). Бывает '--soft' и '--hard'


# Полезные заметки

## Статусы файлов

- 'U' - Unstaged/Untracked - файлы с такой меткой не отслеживаются, изменения в нём не попадут в репозиторий
- 'A' - Added / S - Staged - файлы с такой меткой добавлены в индекс и будут включены в следующий коммит
- 'M' - Modified           - файлы с такой меткой зафиксирован в репозитории (включён хотя бы в 1 предыдущий коммит), но был изменён
- 'D' - Deleted            - файлы с такой меткой были зафиксированы в предыдущем коммите, но были удалены в текущей версии

> [!note]
> Переименование файла велёт к тому, что старое имя файла помечается как 'D', а новое - как 'U'

## Управление файлами, которые будут добавлены в репозиторий и/или помечены для добавления 

Это делается при помощи файла '.gitignore'
Любые папки, расширения файлов, конкретные имена файлов, перечисленные в файле '.gitignore', полностью пропадают из поля зрения репозитория

## Начальная настройка git

- 'git config --global user.email <email>' - для настройки адреса электронной почты
- 'git config --global user.name <name>' - для настройки имени пользователя/логина

Использование команды без флага '--global' настраивает параметры **только в текущем** репозитории (что удобно, если у вас несколько адресов и/или юзернеймов)

## Области в репозитории

1. Рабочая директория
2. Область подготовленных файлов (индекс) - содержание будущего коммита
3. HEAD - последний коммит в репозитории, от него рассчитываются другие характеристики состояния коммита (нового). При откате до какого-либо коммита в истории HEAD перемещается на этот коммит. Для нескольких веток репозитория также существуют свои HEADы.

## Ветки

Ветка (branch) - серия последовательно связанных коммитов (цепочка).

git поддерживает существование в репозитории нескольких веток одновременно. При двух и более ветках хотя бы у 2-х из них должен быть общий источник - коммит, общий для обеих веток.

Активной в одно и то же время может быть только *одна* ветка. При переключении веток в рабочей директории заменяется снимок файловой системы, что может привести к потере незафиксированных изменений.

## Идентификация коммитов

Каждый созданный коммит при фиксации *хэшируется*, т.е. слепок файловой системы, включённый в этот коммит, передаётся в *хэш-функцию*. Полученный хэш является уникальным идентификатором коммита.
До версии 2.29 git использовал хэш-функцию SHA-1, позже начат переход на SHA-256.

Пример такого хэша: '1047b3e8e77057684fa6b56eb2a49b738c210a45'

Во многих случаях достаточно первых 7 знаков хэша для однозначного определения коммита.

Т.е. '1047b3e' == '1047b3e8e77057684fa6b56eb2a49b738c210a45' при указании в качестве параметров различных команд, выводе сведений о коммите и т.п.

## Сборка мусора

Если репозиторий сложен (много файлов, веток, большая история коммитов), индекс репозитория растёт и занимает много места. В таких случаях задействуется встроенный механизм сборки мусора.
Производится автоматически и только для тех коммитов, с которыми не было взаимодействий некоторое время.
Если такие коммиты обнаружены, то к ним применяется механизм замены наиболее старых версий файлов на дельты ('git diff') между ними и текущими версиями файлов
